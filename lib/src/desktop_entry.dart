import 'dart:developer';
import 'dart:io';

import 'package:xdg_desktop_entries/src/exec_line.dart';

class DesktopEntry {
  final String? path;

  final Map<String, String> entries = {};
  final Map<String, DesktopAction> actions = {};

  DesktopEntry({this.path});

  String? get name => entries["Name"];
  String? get exec => entries["Exec"];
  String? get comment => entries["Comment"];
  String? get icon => entries["Icon"];
  bool get terminal => entries["Terminal"]?.toLowerCase() == "true";
  DesktopEntryType? get type => entries.containsKey("Type")
      ? DesktopEntryType.parse(entries["Type"]!)
      : null;
  List<String>? get categories =>
      entries["Categories"]?.split(";").where((e) => e.isNotEmpty).toList();
  List<String>? get keywords =>
      entries["Keywords"]?.split(";").where((e) => e.isNotEmpty).toList();
  List<String>? get mimeTypes =>
      entries["MimeType"]?.split(";").where((e) => e.isNotEmpty).toList();
  List<String>? get actionNames =>
      entries["Actions"]?.split(";").where((e) => e.isNotEmpty).toList();

  ExecLine parseExec() {
    return ExecLine.parse(exec!);
  }

  /// Parses the content of a .desktop file and returns a DesktopEntry object
  static DesktopEntry? fromContent(String content, [String? path]) {
    // method generated by ChatGPT 4o with human-written tests

    final lines = content.split('\n');
    DesktopEntry? desktopEntry;
    DesktopAction? currentAction;
    bool unknownSection = false;

    for (var line in lines) {
      // Skip comments and empty lines
      if (line.startsWith('#') || line.trim().isEmpty) continue;

      // Detect the start of a new section
      if (line.startsWith('[')) {
        // End the current action section (if any)
        if (currentAction != null) {
          desktopEntry?.actions[currentAction.name!] = currentAction;
          currentAction = null;
        }

        // Start the Desktop Entry or an Action section
        if (line.startsWith('[Desktop Entry]')) {
          desktopEntry = DesktopEntry(path: path);
        } else if (line.startsWith('[Desktop Action ')) {
          final actionName = line.substring(16, line.length - 1).trim();
          currentAction = DesktopAction(name: actionName);
        } else {
          unknownSection = true;
        }

        continue;
      }

      // Skip unknown sections
      if (unknownSection) continue;

      // Parse key-value pairs within the current section
      final parts = line.split('=');
      if (parts.length == 2) {
        final key = parts[0].trim();
        final value = parts[1].trim();

        if (currentAction != null) {
          if (currentAction.entries[key] != null) {
            log('Duplicate key in action section: $key');
          }

          // Handle Action-specific key-value pairs
          currentAction.entries[key] = value;
        } else if (desktopEntry != null) {
          if (desktopEntry.entries[key] != null) {
            log('Duplicate key in desktop entry: $key');
          }

          // Handle Desktop Entry-specific key-value pairs
          desktopEntry.entries[key] = value;
        }
      }
    }

    // Add the last action if still active
    if (currentAction != null) {
      desktopEntry?.actions[currentAction.name!] = currentAction;
    }

    // Ensure at least a Name and Exec are present to validate this as an entry
    if (desktopEntry?.name != null && desktopEntry?.exec != null) {
      return desktopEntry;
    }
    return null;
  }

  /// Reads a .desktop file asynchronously and returns a DesktopEntry object
  static Future<DesktopEntry?> fromFile(File file) async {
    if (!await file.exists()) return null;

    final content = await file.readAsString();
    return fromContent(content, file.path);
  }

  /// Finds all .desktop entries in a directory asynchronously
  /// If multiple directories are given, entries from later directories with the same filename will
  /// override entries from earlier directories
  static Future<List<DesktopEntry>> fromDirectories(
    List<Directory> dirs,
  ) async {
    final files = <String, File>{};

    for (final dir in dirs) {
      if (await dir.exists()) {
        final entries = await dir
            .list(recursive: false)
            .where((e) => e.path.endsWith('.desktop'))
            .toList();

        for (final entry in entries) {
          final name = entry.path.split('/').last;
          files[name] = File(entry.path);
        }
      }
    }

    final entries = <DesktopEntry>[];

    for (final file in files.values) {
      final entry = await fromFile(file);
      if (entry != null) {
        entries.add(entry);
      }
    }

    return entries;
  }

  static List<Directory> get standardDirectories => [
        Directory('/usr/share/applications'),
        Directory('/usr/local/share/applications'),
        if (Platform.environment['HOME'] != null)
          Directory(
              '${Platform.environment['HOME']}/.local/share/applications'),
      ];

  /// Access any custom key-value pair
  String? operator [](String key) => entries[key];

  @override
  String toString() {
    return 'DesktopEntry(name: $name, exec: $exec, comment: $comment, icon: $icon, terminal: $terminal, type: $type, categories: $categories, actions: $actions)';
  }
}

/// Class representing a single desktop action
class DesktopAction {
  final String? name;
  final Map<String, String> entries = {};

  DesktopAction({this.name});

  String? get exec => entries['Exec'];
  String? get actionName => entries['Name'];
  String? get icon => entries['Icon'];

  @override
  String toString() {
    return 'DesktopAction(name: $name, exec: $exec, actionName: $actionName, icon: $icon)';
  }
}

/// Enum representing the type of a desktop entry
enum DesktopEntryType {
  application,
  link,
  directory,
  unknown;

  static DesktopEntryType parse(String type) {
    switch (type.toLowerCase()) {
      case 'application':
        return DesktopEntryType.application;
      case 'link':
        return DesktopEntryType.link;
      case 'directory':
        return DesktopEntryType.directory;
      default:
        return DesktopEntryType.unknown;
    }
  }
}
