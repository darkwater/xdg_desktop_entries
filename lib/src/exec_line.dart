import 'desktop_entry.dart';

class ExecLine {
  final List<Argument> args;

  FieldType? get parameterType {
    return args.whereType<ParameterArgument>().firstOrNull?.type;
  }

  ExecLine(this.args);

  List<String> expand(DesktopEntry? entry) =>
      args.expand((arg) => arg.expand(entry)).toList();

  static ExecLine parse(String line) {
    // method generated by ChatGPT 4o with human-written tests

    final literalArgBuffer = StringBuffer();
    final List<Argument> arguments = [];
    bool insideQuotes = false;
    bool escapeNext = false;
    String? specialFieldType;

    // Define a map for valid field codes and their corresponding FieldType
    final fieldCodeMap = {
      'f': FieldType.file,
      'F': FieldType.files,
      'u': FieldType.url,
      'U': FieldType.urls,
      'i': FieldType.icon,
      'k': FieldType.location,
      't': FieldType.translatedName,
    };

    void addLiteralArg() {
      if (literalArgBuffer.isNotEmpty) {
        arguments.add(LiteralArgument(literalArgBuffer.toString()));
        literalArgBuffer.clear();
      }
    }

    final runes = line.runes;
    final iterator = runes.iterator;

    while (iterator.moveNext()) {
      final char = String.fromCharCode(iterator.current);

      if (escapeNext) {
        literalArgBuffer.write(char);
        escapeNext = false;
        continue;
      }

      if (char == r'\') {
        escapeNext = true;
        continue;
      }

      if (char == '"') {
        insideQuotes = !insideQuotes;
        continue;
      }

      if (!insideQuotes) {
        if (char == ' ') {
          addLiteralArg();
          continue;
        }

        if (char == '%') {
          addLiteralArg();
          if (iterator.moveNext()) {
            final nextChar = String.fromCharCode(iterator.current);

            // Handle %%
            if (nextChar == '%') {
              literalArgBuffer.write('%');
              continue;
            }

            // Use the map to look up the field type for the next character
            final fieldType = fieldCodeMap[nextChar];
            if (fieldType != null) {
              // Check if special field type restriction applies
              if (['f', 'F', 'u', 'U'].contains(nextChar) &&
                  specialFieldType != null) {
                throw Exception("Multiple special fields used");
              }

              if (['f', 'F', 'u', 'U'].contains(nextChar)) {
                specialFieldType = nextChar;
                arguments.add(ParameterArgument(fieldType));
              } else {
                arguments.add(SpecialArgument(fieldType));
              }
            } else {
              throw Exception("Invalid field code: $nextChar");
            }
            continue;
          }
        }
      }

      literalArgBuffer.write(char);
    }

    addLiteralArg(); // Add any remaining literal argument

    if (insideQuotes) {
      throw Exception("Unclosed quotes in line: $line");
    }

    return ExecLine(arguments);
  }
}

sealed class Argument {
  List<String> expand(DesktopEntry? entry);
}

class LiteralArgument extends Argument {
  final String value;

  LiteralArgument(this.value);

  @override
  List<String> expand(DesktopEntry? entry) => [value];

  @override
  String toString() => value;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is LiteralArgument &&
          runtimeType == other.runtimeType &&
          value == other.value;

  @override
  int get hashCode => value.hashCode;
}

// %f, %F, %u, %U: may optionally be substituted
class ParameterArgument extends Argument {
  final FieldType type;

  ParameterArgument(this.type);

  @override
  List<String> expand(DesktopEntry? entry) {
    // TODO
    return [];
  }

  @override
  String toString() => "%${type.key}";

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ParameterArgument &&
          runtimeType == other.runtimeType &&
          type == other.type;

  @override
  int get hashCode => type.hashCode;
}

// %i, %c, %k: must be substituted by the caller
class SpecialArgument extends Argument {
  final FieldType type;

  SpecialArgument(this.type);

  @override
  List<String> expand(DesktopEntry? entry, [String? parameter]) {
    final value = switch (type) {
      FieldType.icon => entry?.icon,
      FieldType.translatedName => entry?.name,
      FieldType.location => entry?.path,
      _ => throw "Invalid type: $type",
    };

    if (value == null) return [];

    if (type == FieldType.icon) {
      return ['--icon', value];
    } else {
      return [value];
    }
  }

  @override
  String toString() => "%${type.key}";

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is SpecialArgument &&
          runtimeType == other.runtimeType &&
          type == other.type;

  @override
  int get hashCode => type.hashCode;
}

enum FieldType {
  file("f"),
  files("F"),
  url("u"),
  urls("U"),
  icon("i"),
  translatedName("t"),
  location("k");

  final String key;

  const FieldType(this.key);
}
